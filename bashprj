/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
quick commands:
 g++ main.cpp -> compiles main when in directory
 .a/.out main.cpp -> only works when in directory of project
 ps -> shows working processes
 find help on topic : example - man fork() 
 execvp -> okay to use as its in the same family of exec commands
 chdir(*char) -> changes directory, save current directory and new directory
 ctrl + Z -> stop process
 kill %1 -> kills associated process by number
 */

/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
 */

#include <iostream>
#include <unistd.h>
// used with chdir() -> changes working directory
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>
#include <dirent.h>
#include <string>
#include <stdio.h>
#include <ctype.h>
#include <algorithm>
using namespace std;

struct args
{
	int argc;
	char **argv;
};


void child_parser(int,char*[]);
args* parser(char*);


int main(void)
{
	char input[1500];
	bool runexec = true;
	int checkEXEC;
	for (int i=0;i<1500;i++)
			input[i]= '\0';

	while (true)
	{
		fgets(input,1500,stdin);
		args *aptr;
		aptr = parser(input);
		runexec = non_exec(aptr);

		pid_t REpid = fork(); // returned pid
		switch (REpid)
		{
			case -1:
				perror ("fork");
				exit(1);
				break;
			case 0:
				cout<<">>child process:"<<REpid<<endl;
				if (!runexec)
				checkEXEC = execvp(aptr->argv[0],aptr->argv);
				if (checkEXEC == -1)
				perror("exec");
				exit(0);
				break;
			default:
				if (wait(0)==-1)
					perror("wait");
				cout<<">>Parent process:"<<REpid<<endl;
				break;
		}//end switch
	}// end infinite while
	return 0;
}


args* parser(char* argv)
{
	args *arguments = new args;
	int i = 0;
	int j=0;
	int counter = 0;

	// counts number of arguments 
		while (argv[i] != NULL)
		{
			if (argv[i] != ' ' && argv[i] != '\n' && argv[i] != '\r' && argv[i] != '\t')
				counter++;
			while (argv[i] != ' ' && argv[i] != '\n' && argv[i] != '\r' && argv[i] != '\t' && argv[i] != NULL)
				i++;
			i++;
		}
		// store arguments plus 1 for a null argument
		arguments->argv = new char*[counter + 1];
		arguments->argc = counter;
	
	// split cstring with strtok using delimeters
	char *cmdptr;
	cmdptr = strtok(argv," \n\t\r\a");
	while (cmdptr != NULL)
	{
		arguments->argv[j]=cmdptr;
		j++;
		cout<<cmdptr<<" ";
		cmdptr = strtok(NULL," \n\t\r\a");
	}
cout<<endl;

arguments->argv[arguments->argc] = NULL;
//return pointer containing arguments
return arguments;
}

void non_exe(args *cmdptr)
{

	// cycle through commands
	for (int i =0;i<cmdptr->argc;i++)
	{
		if (cmdptr->argv[i]==std::string("cd"))
		{
			int changedir_test = chdir(cmdptr->argv[i++]);
			if (changedir_test == -1)
				cout<<">>Did not change directories"<<endl;
			else
				{
					USER_PWD();
					break;
				}
		}// if cd

		if (cmdptr->argv[i]==std::string("pwd"))
			{
				USER_PWD();
				break;
			}
	}// end for

}// end non_exe


void USER_PWD()
{
	char buffer[200];
	char *newpath = getcwd(buffer,200);
	string currpath = newpath;
	cout<<">>"<<currpath<<endl;
}


