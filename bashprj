/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
quick commands:
 g++ main.cpp -> compiles main when in directory
 .a/.out main.cpp -> only works when in directory of project
 ps -> shows working processes
 find help on topic : example - man fork() 
 execvp -> okay to use as its in the same family of exec commands
 chdir(*char) -> changes directory, save current directory and new directory
 ctrl + Z -> stop process
 kill %1 -> kills associated process by number
 */

/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
 */

#include <iostream>
#include <unistd.h>
// used with chdir() -> changes working directory
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>
#include <dirent.h>
#include <string>
#include <stdio.h>
#include <ctype.h>
#include <algorithm>
using namespace std;

struct args
{
	int argc;
	char **argv;
};


void child_parser(int,char*[]);
args* parser(char*);


int main(void)
{
	char input[1500];

	while (true)
	{
		fgets(input,1500,stdin);
		parser(input);


		pid_t REpid = fork(); // returned pid
		switch (REpid)
		{
			case -1:
				perror ("fork went wrong");
				exit(1);
				break;
			case 0:
				cout<<"In child:"<<REpid<<endl;
				//child_parser(argc,argv);
				exit(0);
				break;
			default:
				if (wait(0)==-1)
					perror("wait failed");
				cout<<"parrent:"<<REpid<<endl;
				break;
		}//end switch
	}// end infinite while
	return 0;
}



args* parser(char* argv)
{
	args *arguments = new args;
	int counter = 0;
	int i =0;
	int j =0;
	string segment ="";

	while(argv[i] != NULL)
	{
		if (argv[i] == ' ')
		counter++;
		while (argv[i]==' ')
			i++;
		i++;
	}

	// store arguments plus 1 for a null argument
	arguments->argv = new char*[counter +1];
	arguments->argc = counter+1;

	for (int i=0;i<1500;i++)
	{
		if ((argv[i] != '/n') &&( argv[i] != '/r') && (argv[i] != '/t'))
		{
			if (argv[i]== ' ')
			{
				char *temp = new char[segment.size()+1];

				for (int i=0;i<segment.size();i++)
					temp[i]=segment[i];

				temp[segment.size()+1] = NULL;
				arguments->argv[j]=temp;
				j++;
				segment="";
			}
			else
				segment += argv[i];
		}
		if (argv[i] == NULL)
			break;
	}// end for

return arguments;
}




void child_parser(int argc,char* argv[])
{
	/*
	 * Steps:
	 * 1. parse string
	 * 2. take off any /n,/r,/t chars at end
	 * 3. attach NULL end of array
	 */
	// Changes directories
	if (argv[1]== std::string("cd"))
	{
		string stuff;
		int changedir_test = chdir(argv[2]);
		if (changedir_test == -1)
			cout<<"Did not change directories"<<endl;

		// Success on changing directories
		// so display current path
		else
		{
			char buffer[200];
			char *newpath = getcwd(buffer,200);
			string currpath = newpath;
			cout<<currpath<<endl;
		}
	}
	// Executes commands

	else
	{
		cout<<"in execvp part"<<endl;
		char *myc[3];
		string lscmd = "ls";
		string dshl = "-l";

		myc[0] = (char*)lscmd.c_str();
		myc[1] = (char*)dshl.c_str();
		myc[2] = NULL;

		int checkEXEC = execvp(myc[0],myc);
		//int checkEXEC = execvp(argv[1],argv);
		if (checkEXEC == -1)
			perror("exec encountered an error");
	}

}
