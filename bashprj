/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
quick commands:
 g++ main.cpp -> compiles main when in directory
 .a/.out main.cpp -> only works when in directory of project
 ps -> shows working processes
 find help on topic : example - man fork() 
 execvp -> okay to use as its in the same family of exec commands
 chdir(*char) -> changes directory, save current directory and new directory
 ctrl + Z -> stop process
 kill %1 -> kills associated process by number
 */

/*
 * main.cpp
 *
 *  Created on: Jan 26, 2017
 *      Author: andrew
 */

#include <iostream>
#include <unistd.h>
// used with chdir() -> changes working directory
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>
#include <dirent.h>
#include <string>
#include <stdio.h>
#include <ctype.h>
#include <algorithm>
using namespace std;

struct args
{
	int argc;
	char **argv;
};


void child_parser(int,char*[]);
args* parser(char*);


int main(void)
{
	char input[1500];

	while (true)
	{
		fgets(input,1500,stdin);
		args *aptr;
		aptr = parser(input);


		pid_t REpid = fork(); // returned pid
		switch (REpid)
		{
			case -1:
				perror ("fork went wrong");
				exit(1);
				break;
			case 0:
				cout<<"In child:"<<REpid<<endl;
				//child_parser(argc,argv);
				exit(0);
				break;
			default:
				if (wait(0)==-1)
					perror("wait failed");
				cout<<"parrent:"<<REpid<<endl;
				break;
		}//end switch
	}// end infinite while
	return 0;
}


args* parser(char* argv)
{
	args *arguments = new args;
	int i = 0;
	int j=0;
	int counter = 0;

	// counts number of arguments 
		while (argv[i] != NULL)
		{
			if (argv[i] != ' ' && argv[i] != '\n' && argv[i] != '\r' && argv[i] != '\t')
				counter++;
			while (argv[i] != ' ' && argv[i] != '\n' && argv[i] != '\r' && argv[i] != '\t' && argv[i] != NULL)
				i++;
			i++;
		}
		// store arguments plus 1 for a null argument
		arguments->argv = new char*[counter + 1];
		arguments->argc = counter;
	
	// split cstring with strtok using delimeters
	char *cmdptr;
	cmdptr = strtok(argv," \n\t\r\a");
	while (cmdptr != NULL)
	{
		arguments->argv[j]=cmdptr;
		j++;
		cout<<cmdptr<<" ";
		cmdptr = strtok(NULL," \n\t\r\a");
	}
cout<<endl;

arguments->argv[arguments->argc] = NULL;
//return pointer containing arguments
return arguments;
}




void child_parser(int argc,char* argv[])
{
	/*
	 * Steps:
	 * 1. parse string
	 * 2. take off any /n,/r,/t chars at end
	 * 3. attach NULL end of array
	 */
	// Changes directories
	if (argv[1]== std::string("cd"))
	{
		string stuff;
		int changedir_test = chdir(argv[2]);
		if (changedir_test == -1)
			cout<<"Did not change directories"<<endl;

		// Success on changing directories
		// so display current path
		else
		{
			char buffer[200];
			char *newpath = getcwd(buffer,200);
			string currpath = newpath;
			cout<<currpath<<endl;
		}
	}
	// Executes commands

	else
	{
		cout<<"in execvp part"<<endl;
		char *myc[3];
		string lscmd = "ls";
		string dshl = "-l";

		myc[0] = (char*)lscmd.c_str();
		myc[1] = (char*)dshl.c_str();
		myc[2] = NULL;

		int checkEXEC = execvp(myc[0],myc);
		//int checkEXEC = execvp(argv[1],argv);
		if (checkEXEC == -1)
			perror("exec encountered an error");
	}

}
